function create_heatmap(intensity_image,dsfactor,outputdir,templatenifti,numcpu,varargin)
% create_heatmap(intensity_image,dsfactor,output_image,templatenifti,varargin)
% 
% INTENSITYIMG     N4 corrected CFOS image. It is used to find the centroid of
%                  a cell, or the brightest point, as used by ClearMap code.
% DSFACTOR         Downsampling factor, e.g. 6x6x5 (separated by x). It is the
%                  same factor that was used to downsample the cFOS image for
%                  registration.
% OUTPUTDIR        Output directory where heat map images (nifti) in the downsampled 
%                  space will be written. They need to be transformed to the atlas
%                  space later.
% TEMPLATENIFTI    Template nifti image in downsampled image space used only for
%                  headers. It is usually the downsampled cFOS image 
%                  (e.g. downsampled_7x7x5_brain.nii.gz)
%                  ** THIS IS NOT THE ATLAS **.
% NUMCPU           Number of parallel processes
% CELLPXLIST       Multiple ABCD_cellpixelIDlist.mat files generated by the
%                  Generate_Stats script. The mat files contain cellpixelIDlist
%                  structure containing 1122 labels. Each label contains a Nx5
%                  matrix, where N=total number of cell pixels. The columns
%                  contains uid_of_a_cell, volume_of_a_cell,I,J,K. The integer
%                  part of the UID contains the label

if isdeployed
    numcpu=str2num(numcpu);
end
temp=strsplit(dsfactor,{'x','X'});
ds=zeros(1,3);
for t=1:3
    ds(t)=str2num(temp{t});
end
dim1=find_dimensions(intensity_image);
fprintf('Input image size = %d x %d x %d (HxWxD).\n',dim1(1),dim1(2),dim1(3));




N=length(varargin);
for i=1:N
    if ~isfile(varargin{i})
        fprintf('ERROR: Input must be a .mat file generated by Generate_Stats script.\n');
        fprintf('ERROR: You entered %s\n',varargin{i});
        return;
    end
end
fprintf('%d cell segmentation images found.\n',N);
disp(varargin);
if ~isfolder(outputdir)
    mkdir(outputdir);
end




rad=5;
se=strel('sphere',rad);
se=single(se.Neighborhood);
if isempty(gcp('nocreate'))
    setenv('MATLAB_SHELL','/bin/sh');
    username=getenv('USER');
    tempdirname=tempname(fullfile('/home',username,'.matlab','local_cluster_jobs','R2022a'));
    mkdir(tempdirname);
    cluster=parallel.cluster.Local();
    cluster.NumWorkers=numcpu;
    cluster.JobStorageLocation=tempdirname;
    fprintf('Temp Job directory = %s\n',tempdirname);
    pl=parpool(cluster);
else
    pl=[];
end

for j=1:N
    fprintf('Working on %s\n',varargin{j});
    xx=load(varargin{j});
    template=load_untouch_nii(templatenifti);
    template.img=zeros(size(template.img),'single');
    dim2=size(template.img);
    L=size(xx.cellpixelIDlist,1);
    TINDX=cell(L,1);
    tic
    parfor t=1:L  % number of labels
        a=xx.cellpixelIDlist{t};
        temp=[];
        if ~isempty(a)
            U=unique(a(:,1)); % unique ID of a cell
            
            label=unique(floor(U));    
            temp=zeros(length(U),3);
%             fprintf('Label %d, number of cells %d\n',label,length(U));
            for uu=1:length(U)
                u=U(uu);
                indx=find(a(:,1)==u);
                            
                I=a(indx,3);J=a(indx,4);K=a(indx,5); %
                vol=read_image(intensity_image, min(I),max(I),min(J),max(J),min(K),max(K));
                I1=I;J1=J;K1=K;
                I1=I1-min(I)+1;J1=J1-min(J)+1;K1=K1-min(K)+1;
                indx2=sub2ind(size(vol),I1,J1,K1);
                b=vol(indx2);
                c=find(vol==max(b));
                c=c(1);
                [I2 J2 K2]=ind2sub(size(vol),c);
                I2=I2+min(I)-1;J2=J2+min(J)-1;K2=K2+min(K)-1;

                
                % Although in tif format, I,J,K is height-width-depth, Nifti has
                % width-height-depth as I,J,K
                I=round(J2/ds(1));J=round(I2/ds(2));K=round(K2/ds(3));
                I(I==0)=1;J(J==0)=1;K(K==0)=1;
                temp(uu,:)=[I J K];


                
                   

            end
        end
        TINDX{t}=temp;
    end
    toc
    f=0;
    for t=1:L
        f=f+size(TINDX{t},1);
    end
    TINDX2=zeros([f 3]);
    f=0;
    for t=1:L
        f1=size(TINDX{t},1);
        TINDX2(f+1:f+f1,:)=TINDX{t};
        f=f+f1;
    end
    f=size(TINDX2,1);
    for m=1:f
        I=TINDX2(m,1);J=TINDX2(m,2);K=TINDX2(m,3);
        if (I>rad && I<=dim2(1)-rad) && (J>rad && J<=dim2(2)-rad) && ...
                (K>rad && K<=dim2(3)-rad)
            template.img(I-rad:I+rad,J-rad:J+rad,K-rad:K+rad)=...
                template.img(I-rad:I+rad,J-rad:J+rad,K-rad:K+rad)+se;
        end

    end
    fprintf('\n');
%     toc
%     template.img=template.img/length(find(se>0));
    
    [~,output_image,~]=fileparts(varargin{j});
    output_image=fullfile(outputdir,[output_image '_heatmap_imagespace.nii.gz']);
                
    template.fileprefix=basename(output_image);
    template.hdr.dime.bitpix=32;
    template.hdr.dime.datatype=16;
    template.hdr.dime.cal_max=max(template.img(:));
    template.hdr.dime.cal_min=min(template.img(:));
    fprintf('Writing %s\n',output_image);
    save_untouch_nii(template,output_image);
    
end
end
    

function vol=read_image(inputdir,I1,I2,J1,J2,K1,K2)
% This function reads the volume within a cube mentioned by [I1:I2 J1:J2 K1:K2]
% imagetype is either uint16 (for intensity images) or logical (for binary
% images)
% DS indicate downsampling factor in X-Y, usually 1.

input=rdir(fullfile(inputdir,'*.tif'));

dim=[I2-I1+1 J2-J1+1 K2-K1+1];

vol=cell(dim(3),1);
klist=K1:K2;
% count=1;
for kk=1:length(klist)
   
    x=imread(input(klist(kk)).name,'PixelRegion',{[I1 I2],[J1 J2]});
    vol{kk}=uint16(x);
end
vol=celltomat(vol);
    
end



